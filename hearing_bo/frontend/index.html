<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Hearing Calibration</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
    <style>
        body { padding: 1rem 2rem; }
        .hidden { display: none; }
        #plot-container { min-height: 450px; margin-top: 1rem; }
        .slider-group {
            border: 1px solid var(--muted-border-color);
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
        }
        .indicator {
            width: 15px;
            height: 15px;
            background-color: var(--muted-border-color);
            border-radius: 50%;
            margin-right: 1rem;
            transition: background-color 0.2s;
        }
        .indicator.playing {
            background-color: var(--pico-color-red-500);
        }
        .slider-group .content { flex-grow: 1; }
        #volume-display { font-weight: bold; margin-left: 1rem; }
    </style>
</head>
<body>
    <main class="container">
        <header>
            <h1>Hearing Calibration with Bayesian Optimization</h1>
            <p>Find your equal-loudness curve by comparing frequencies against a fixed root tone.</p>
        </header>

        <!-- SETUP SECTION -->
        <section id="setup-section">
            <article>
                <hgroup>
                    <h2>1. Setup</h2>
                    <p>Select your audio device and set the root tone properties.</p>
                </hgroup>
                <div class="grid">
                    <div>
                        <label for="audio-device">Audio Device</label>
                        <select id="audio-device" required></select>
                    </div>
                    <div>
                        <label for="root-freq">Root Frequency (Hz)</label>
                        <input type="number" id="root-freq" value="1000" step="50">
                    </div>
                </div>
                <label for="root-volume">Root Volume (dBFS)</label>
                <input type="number" id="root-volume" value="-25" step="1">
                <br><br>
                <button id="start-btn">Start Test</button>
            </article>
        </section>

        <!-- TEST SECTION -->
        <section id="test-section" class="hidden">
            <article>
                <hgroup>
                    <h2>2. Perform Test</h2>
                    <p>Start the auto-cycle and adjust the three sliders until all test tones sound as loud as the root tone.</p>
                </hgroup>
                
                <div class="grid">
                    <div>
                        <label for="cycle-speed">Cycle Speed (ms)</label>
                        <input type="number" id="cycle-speed" value="800" step="100" min="200">
                    </div>
                    <div>
                        <label>Â </label>
                        <button id="cycle-toggle-btn">Start Auto-Cycle</button>
                    </div>
                </div>

                <!-- Sliders will be dynamically inserted here -->
                <div id="sliders-container"></div>
                
                <br>
                <button id="confirm-btn" aria-busy="false">Confirm and Go to Next Set</button>
            </article>
            
            <button id="toggle-axis-btn" class="secondary outline">Toggle X-Axis (Log/Linear)</button>
            <div id="plot-container"></div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- State ---
            let ws;
            let currentTestPoints = {}; // {low: 120, mid: 750, high: 6000}
            let rootToneInfo = {};
            let cycleInterval = null;
            let isCyclePlaying = false;
            let playbackQueue = [];
            let plotLayout = {
                title: 'Equal Loudness Curve',
                xaxis: { title: 'Frequency (Hz)', type: 'log', autorange: true },
                yaxis: { title: 'Volume (dBFS)', autorange: true, range: [-80, 0]},
                margin: { t: 40, b: 40, l: 40, r: 20 },
                showlegend: false
            };

            // --- DOM Elements ---
            const setupSection = document.getElementById('setup-section');
            const testSection = document.getElementById('test-section');
            const audioDeviceSelect = document.getElementById('audio-device');
            const rootFreqInput = document.getElementById('root-freq');
            const rootVolumeInput = document.getElementById('root-volume');
            const startBtn = document.getElementById('start-btn');
            const confirmBtn = document.getElementById('confirm-btn');
            const slidersContainer = document.getElementById('sliders-container');
            const plotContainer = document.getElementById('plot-container');
            const cycleToggleBtn = document.getElementById('cycle-toggle-btn');
            const cycleSpeedInput = document.getElementById('cycle-speed');
            const toggleAxisBtn = document.getElementById('toggle-axis-btn');

            // --- Initialization ---
            const init = async () => {
                try {
                    const response = await fetch('/api/devices');
                    const devices = await response.json();
                    audioDeviceSelect.innerHTML = '';
                    devices.forEach(device => audioDeviceSelect.add(new Option(device.name, device.id)));
                } catch (error) {
                    alert("Could not connect to the backend. Ensure it's running.");
                }
            };

            // --- WebSocket Logic ---
            const connectWebSocket = () => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
                ws.onmessage = handleWebSocketMessage;
                ws.onclose = () => alert("WebSocket connection closed. Please refresh.");
                ws.onerror = (e) => console.error("WebSocket error:", e);
            };

            const handleWebSocketMessage = (event) => {
                const message = JSON.parse(event.data);
                switch (message.type) {
                    case 'test_started':
                        setupSection.classList.add('hidden');
                        testSection.classList.remove('hidden');
                        initPlot();
                        break;
                    case 'new_points':
                        currentTestPoints = message.points;
                        createSliders(currentTestPoints);
                        if (isCyclePlaying) startCycle(); // Keep playing if it was on
                        confirmBtn.disabled = false;
                        confirmBtn.setAttribute('aria-busy', 'false');
                        break;
                    case 'update_curve':
                        drawPlot(message.data);
                        break;
                }
            };
            
            const sendMessage = (data) => ws?.readyState === WebSocket.OPEN && ws.send(JSON.stringify(data));

            // --- UI Creation ---
            const createSliders = (points) => {
                slidersContainer.innerHTML = ''; // Clear old sliders
                
                // Root tone (not a slider, but shown for context)
                slidersContainer.insertAdjacentHTML('beforeend', `
                    <div class="slider-group">
                        <div class="indicator" id="indicator-root"></div>
                        <div class="content"><strong>Root Tone:</strong> ${rootToneInfo.root_freq} Hz at ${rootToneInfo.root_volume} dBFS</div>
                    </div>`);

                Object.entries(points).forEach(([band, freq]) => {
                    const sliderHTML = `
                        <div class="slider-group" id="group-${band}">
                            <div class="indicator" id="indicator-${band}"></div>
                            <div class="content">
                                <label for="slider-${band}">
                                    ${band.charAt(0).toUpperCase() + band.slice(1)} Freq: ${Math.round(freq)} Hz
                                    <span id="display-${band}" style="font-weight:bold; margin-left: 1rem;">-40.0 dB</span>
                                </label>
                                <input type="range" min="-80" max="0" value="-40" step="0.5" id="slider-${band}" data-freq="${freq}" data-band="${band}">
                            </div>
                        </div>`;
                    slidersContainer.insertAdjacentHTML('beforeend', sliderHTML);
                });

                // Add event listeners to new sliders
                slidersContainer.querySelectorAll('input[type="range"]').forEach(slider => {
                    slider.addEventListener('input', (e) => {
                        const band = e.target.dataset.band;
                        document.getElementById(`display-${band}`).textContent = `${parseFloat(e.target.value).toFixed(1)} dB`;
                    });
                });
            };

            // --- Plotting ---
            const initPlot = () => Plotly.newPlot(plotContainer, [], plotLayout, {responsive: true});
            const drawPlot = (data) => {
                 if (!data.freqs || data.freqs.length === 0) return;
                const { freqs, mean, std, points } = data;
                const upper_bound = mean.map((m, i) => m + std[i]);
                const lower_bound = mean.map((m, i) => m - std[i]);
                const traces = [
                    { x: points.freqs, y: points.volumes, mode: 'markers', type: 'scatter', marker: { color: 'red', size: 8 }},
                    { x: freqs, y: mean, mode: 'lines', type: 'scatter', line: { color: 'var(--pico-primary)', width: 3 }},
                    { x: freqs, y: lower_bound, mode: 'lines', type: 'scatter', line: { width: 0 }},
                    { x: freqs, y: upper_bound, mode: 'lines', type: 'scatter', fill: 'tonexty', fillcolor: 'rgba(0,117,255,0.2)', line: { width: 0 }}
                ];
                Plotly.react(plotContainer, traces, plotLayout);
            };

            // --- Audio Cycle Logic ---
            const shuffle = (array) => array.sort(() => Math.random() - 0.5);

            const startCycle = () => {
                if (cycleInterval) clearInterval(cycleInterval);
                const speed = parseInt(cycleSpeedInput.value, 10);
                
                // Build and shuffle the playback queue
                playbackQueue = shuffle(['root', ...Object.keys(currentTestPoints)]);
                
                let queueIndex = 0;
                const playNext = () => {
                    const currentBand = playbackQueue[queueIndex];
                    playToneForBand(currentBand);
                    queueIndex = (queueIndex + 1) % playbackQueue.length;
                };

                playNext(); // Play the first one immediately
                cycleInterval = setInterval(playNext, speed);
                isCyclePlaying = true;
                cycleToggleBtn.textContent = 'Pause Auto-Cycle';
            };

            const stopCycle = () => {
                if (cycleInterval) clearInterval(cycleInterval);
                cycleInterval = null;
                isCyclePlaying = false;
                cycleToggleBtn.textContent = 'Start Auto-Cycle';
                document.querySelectorAll('.indicator').forEach(ind => ind.classList.remove('playing'));
            };
            
            const playToneForBand = (band) => {
                document.querySelectorAll('.indicator').forEach(ind => ind.classList.remove('playing'));
                document.getElementById(`indicator-${band}`).classList.add('playing');
                
                if (band === 'root') {
                    sendMessage({type: 'play_tone', frequency: rootToneInfo.root_freq, volume: rootToneInfo.root_volume});
                } else {
                    const slider = document.getElementById(`slider-${band}`);
                    sendMessage({type: 'play_tone', frequency: slider.dataset.freq, volume: slider.value});
                }
            };
            
            // --- Event Listeners ---
            startBtn.addEventListener('click', () => {
                // *** FIX IS HERE ***
                rootToneInfo = { root_freq: rootFreqInput.value, root_volume: rootVolumeInput.value };
                connectWebSocket();
                ws.onopen = () => sendMessage({ type: 'start_test', ...rootToneInfo, device_id: audioDeviceSelect.value });
            });

            cycleToggleBtn.addEventListener('click', () => isCyclePlaying ? stopCycle() : startCycle());
            cycleSpeedInput.addEventListener('change', () => { if (isCyclePlaying) startCycle(); });

            confirmBtn.addEventListener('click', () => {
                // Don't stop the cycle, just send data and wait for new points
                confirmBtn.disabled = true;
                confirmBtn.setAttribute('aria-busy', 'true');
                const submissions = Array.from(slidersContainer.querySelectorAll('input[type="range"]'))
                    .map(slider => ({
                        freq: parseFloat(slider.dataset.freq),
                        vol: parseFloat(slider.value)
                    }));
                sendMessage({ type: 'submit_volumes', submissions });
            });
            
            toggleAxisBtn.addEventListener('click', () => {
                plotLayout.xaxis.type = (plotLayout.xaxis.type === 'log') ? 'linear' : 'log';
                Plotly.relayout(plotContainer, plotLayout);
            });

            init();
        });
    </script>
</body>
</html>